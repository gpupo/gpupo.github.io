<!DOCTYPE html>
<html lang="pt-BR"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D | Gilmar Pupo</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D" />
<meta property="og:locale" content="pt_BR" />
<meta name="description" content="Imagina que voc√™ tem um kit de produtos e quer saber qual o tamanho da caixa que voc√™ precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma √∫nica coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D √© uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D √© uma abordagem baseada em algoritmos gen√©ticos para resolver problemas de otimiza√ß√£o de empacotamento tridimensional. O objetivo do problema de empacotamento 3D √© colocar um conjunto de itens com dimens√µes tridimensionais (comprimento, largura e altura) em um n√∫mero m√≠nimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA √© uma classe de algoritmos gen√©ticos que utiliza chaves aleat√≥rias enviesadas para representar solu√ß√µes. O algoritmo gen√©tico √© uma t√©cnica de busca heur√≠stica inspirada no processo de evolu√ß√£o natural. Ele trabalha com uma popula√ß√£o de solu√ß√µes candidatas (indiv√≠duos), onde cada indiv√≠duo representa uma solu√ß√£o potencial para o problema. Essas solu√ß√µes evoluem ao longo do tempo por meio de opera√ß√µes como sele√ß√£o, cruzamento (recombina√ß√£o) e muta√ß√£o. Aqui est√° uma descri√ß√£o geral do BRKGA para o problema de empacotamento 3D: Inicializa√ß√£o: Gere uma popula√ß√£o inicial de solu√ß√µes candidatas aleat√≥rias, representadas por chaves aleat√≥rias enviesadas. Avalia√ß√£o: Calcule a aptid√£o (fitness) de cada indiv√≠duo na popula√ß√£o. No caso do problema de empacotamento 3D, a aptid√£o pode ser medida como o n√∫mero de compartimentos utilizados ou o espa√ßo desperdi√ßado nos compartimentos. Sele√ß√£o: Selecione os indiv√≠duos da popula√ß√£o atual com base em sua aptid√£o. Os indiv√≠duos com melhor aptid√£o t√™m maior probabilidade de serem selecionados. Cruzamento: Combine os indiv√≠duos selecionados para criar novas solu√ß√µes candidatas. No BRKGA, isso √© feito combinando as chaves aleat√≥rias enviesadas dos pais para gerar chaves para a prole. Muta√ß√£o: Introduza pequenas perturba√ß√µes nas solu√ß√µes candidatas rec√©m-criadas. Isso √© feito alterando aleatoriamente algumas das chaves enviesadas. Atualiza√ß√£o da popula√ß√£o: Substitua uma parte da popula√ß√£o atual pelas novas solu√ß√µes candidatas geradas. Condi√ß√£o de parada: Verifique se a condi√ß√£o de parada foi atingida, como um n√∫mero m√°ximo de gera√ß√µes ou um limite de tempo. Se a condi√ß√£o de parada n√£o for atingida, volte ao passo 2. Retorne a melhor solu√ß√£o encontrada. O BRKGA para o problema de empacotamento 3D √© uma abordagem heur√≠stica que pode fornecer solu√ß√µes de alta qualidade em um tempo razo√°vel. No entanto, como outros algoritmos gen√©ticos, ele n√£o garante encontrar a solu√ß√£o √≥tima global em todos os casos. Na Pr√°tica Defina os produtos e suas quantidades, como no exemplo fornecido: python" />
<meta property="og:description" content="Imagina que voc√™ tem um kit de produtos e quer saber qual o tamanho da caixa que voc√™ precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma √∫nica coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D √© uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D √© uma abordagem baseada em algoritmos gen√©ticos para resolver problemas de otimiza√ß√£o de empacotamento tridimensional. O objetivo do problema de empacotamento 3D √© colocar um conjunto de itens com dimens√µes tridimensionais (comprimento, largura e altura) em um n√∫mero m√≠nimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA √© uma classe de algoritmos gen√©ticos que utiliza chaves aleat√≥rias enviesadas para representar solu√ß√µes. O algoritmo gen√©tico √© uma t√©cnica de busca heur√≠stica inspirada no processo de evolu√ß√£o natural. Ele trabalha com uma popula√ß√£o de solu√ß√µes candidatas (indiv√≠duos), onde cada indiv√≠duo representa uma solu√ß√£o potencial para o problema. Essas solu√ß√µes evoluem ao longo do tempo por meio de opera√ß√µes como sele√ß√£o, cruzamento (recombina√ß√£o) e muta√ß√£o. Aqui est√° uma descri√ß√£o geral do BRKGA para o problema de empacotamento 3D: Inicializa√ß√£o: Gere uma popula√ß√£o inicial de solu√ß√µes candidatas aleat√≥rias, representadas por chaves aleat√≥rias enviesadas. Avalia√ß√£o: Calcule a aptid√£o (fitness) de cada indiv√≠duo na popula√ß√£o. No caso do problema de empacotamento 3D, a aptid√£o pode ser medida como o n√∫mero de compartimentos utilizados ou o espa√ßo desperdi√ßado nos compartimentos. Sele√ß√£o: Selecione os indiv√≠duos da popula√ß√£o atual com base em sua aptid√£o. Os indiv√≠duos com melhor aptid√£o t√™m maior probabilidade de serem selecionados. Cruzamento: Combine os indiv√≠duos selecionados para criar novas solu√ß√µes candidatas. No BRKGA, isso √© feito combinando as chaves aleat√≥rias enviesadas dos pais para gerar chaves para a prole. Muta√ß√£o: Introduza pequenas perturba√ß√µes nas solu√ß√µes candidatas rec√©m-criadas. Isso √© feito alterando aleatoriamente algumas das chaves enviesadas. Atualiza√ß√£o da popula√ß√£o: Substitua uma parte da popula√ß√£o atual pelas novas solu√ß√µes candidatas geradas. Condi√ß√£o de parada: Verifique se a condi√ß√£o de parada foi atingida, como um n√∫mero m√°ximo de gera√ß√µes ou um limite de tempo. Se a condi√ß√£o de parada n√£o for atingida, volte ao passo 2. Retorne a melhor solu√ß√£o encontrada. O BRKGA para o problema de empacotamento 3D √© uma abordagem heur√≠stica que pode fornecer solu√ß√µes de alta qualidade em um tempo razo√°vel. No entanto, como outros algoritmos gen√©ticos, ele n√£o garante encontrar a solu√ß√£o √≥tima global em todos os casos. Na Pr√°tica Defina os produtos e suas quantidades, como no exemplo fornecido: python" />
<link rel="canonical" href="https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" />
<meta property="og:url" content="https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" />
<meta property="og:site_name" content="Gilmar Pupo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-18T13:46:00-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-18T13:46:00-03:00","datePublished":"2023-03-18T13:46:00-03:00","description":"Imagina que voc√™ tem um kit de produtos e quer saber qual o tamanho da caixa que voc√™ precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma √∫nica coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D √© uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D √© uma abordagem baseada em algoritmos gen√©ticos para resolver problemas de otimiza√ß√£o de empacotamento tridimensional. O objetivo do problema de empacotamento 3D √© colocar um conjunto de itens com dimens√µes tridimensionais (comprimento, largura e altura) em um n√∫mero m√≠nimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA √© uma classe de algoritmos gen√©ticos que utiliza chaves aleat√≥rias enviesadas para representar solu√ß√µes. O algoritmo gen√©tico √© uma t√©cnica de busca heur√≠stica inspirada no processo de evolu√ß√£o natural. Ele trabalha com uma popula√ß√£o de solu√ß√µes candidatas (indiv√≠duos), onde cada indiv√≠duo representa uma solu√ß√£o potencial para o problema. Essas solu√ß√µes evoluem ao longo do tempo por meio de opera√ß√µes como sele√ß√£o, cruzamento (recombina√ß√£o) e muta√ß√£o. Aqui est√° uma descri√ß√£o geral do BRKGA para o problema de empacotamento 3D: Inicializa√ß√£o: Gere uma popula√ß√£o inicial de solu√ß√µes candidatas aleat√≥rias, representadas por chaves aleat√≥rias enviesadas. Avalia√ß√£o: Calcule a aptid√£o (fitness) de cada indiv√≠duo na popula√ß√£o. No caso do problema de empacotamento 3D, a aptid√£o pode ser medida como o n√∫mero de compartimentos utilizados ou o espa√ßo desperdi√ßado nos compartimentos. Sele√ß√£o: Selecione os indiv√≠duos da popula√ß√£o atual com base em sua aptid√£o. Os indiv√≠duos com melhor aptid√£o t√™m maior probabilidade de serem selecionados. Cruzamento: Combine os indiv√≠duos selecionados para criar novas solu√ß√µes candidatas. No BRKGA, isso √© feito combinando as chaves aleat√≥rias enviesadas dos pais para gerar chaves para a prole. Muta√ß√£o: Introduza pequenas perturba√ß√µes nas solu√ß√µes candidatas rec√©m-criadas. Isso √© feito alterando aleatoriamente algumas das chaves enviesadas. Atualiza√ß√£o da popula√ß√£o: Substitua uma parte da popula√ß√£o atual pelas novas solu√ß√µes candidatas geradas. Condi√ß√£o de parada: Verifique se a condi√ß√£o de parada foi atingida, como um n√∫mero m√°ximo de gera√ß√µes ou um limite de tempo. Se a condi√ß√£o de parada n√£o for atingida, volte ao passo 2. Retorne a melhor solu√ß√£o encontrada. O BRKGA para o problema de empacotamento 3D √© uma abordagem heur√≠stica que pode fornecer solu√ß√µes de alta qualidade em um tempo razo√°vel. No entanto, como outros algoritmos gen√©ticos, ele n√£o garante encontrar a solu√ß√£o √≥tima global em todos os casos. Na Pr√°tica Defina os produtos e suas quantidades, como no exemplo fornecido: python","headline":"Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/"},"url":"https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.gpupo.com/feed.xml" title="Gilmar Pupo" /><script async src="https://www.googletagmanager.com/gtag/js?id=383379184"></script>
<script>
  window['ga-disable-383379184'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '383379184');
</script>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Gilmar Pupo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/">üìù Artigos</a><a class="page-link" href="/lessons/">üßæ Aulas</a><a class="page-link" href="/livros/">üìöLivros</a><a class="page-link" href="/about/">üìú About</a><a class="page-link" href="/updates/">üí¨Updates</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-03-18T13:46:00-03:00" itemprop="datePublished">
        Mar 18, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div>
<p>
Imagina que voc√™ tem um kit de produtos e quer saber qual o tamanho da caixa que voc√™ precisa. Um algoritmo simples pode facilmente
<strong>
empilhar todos os produtos em uma √∫nica coluna
</strong>
e atrapalhar os seus planos, certo?
</p>
<p>
Aplicar o
<strong>
BRKGA
</strong>
(Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D √© uma alternativa.
</p>
<figure class="slate-resizable-image-embed slate-image-embed__resize-full-width">
<div>
</div>
<div>
</div>
<img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE3T_OBnXpR1w" src="https://media.licdn.com/dms/image/D4D12AQE3T_OBnXpR1w/article-inline_image-shrink_1000_1488/0/1679147721879?e=1691625600&amp;v=beta&amp;t=6085Ctij9uEemKRXMS8HixhIrDk8IV-TunfnBRN4Oj8" />
</figure>
<h2>
Teoria
</h2>
<p>
O
<strong>
BRKGA
</strong>
(Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D √© uma abordagem baseada em algoritmos gen√©ticos para resolver problemas de otimiza√ß√£o de empacotamento tridimensional. O objetivo do problema de empacotamento 3D √© colocar um conjunto de itens com dimens√µes tridimensionais (comprimento, largura e altura) em um n√∫mero m√≠nimo de compartimentos (ou caixas) com capacidades limitadas.
</p>
<p>
O BRKGA √© uma classe de algoritmos gen√©ticos que utiliza chaves aleat√≥rias enviesadas para representar solu√ß√µes. O algoritmo gen√©tico √© uma t√©cnica de busca heur√≠stica inspirada no processo de evolu√ß√£o natural. Ele trabalha com uma popula√ß√£o de solu√ß√µes candidatas (indiv√≠duos), onde cada indiv√≠duo representa uma solu√ß√£o potencial para o problema. Essas solu√ß√µes evoluem ao longo do tempo por meio de opera√ß√µes como sele√ß√£o, cruzamento (recombina√ß√£o) e muta√ß√£o.
</p>
<p>
Aqui est√° uma descri√ß√£o geral do BRKGA para o problema de empacotamento 3D:
</p>
<ol>
<li>
Inicializa√ß√£o: Gere uma popula√ß√£o inicial de solu√ß√µes candidatas aleat√≥rias, representadas por chaves aleat√≥rias enviesadas.
</li>
<li>
Avalia√ß√£o: Calcule a aptid√£o (fitness) de cada indiv√≠duo na popula√ß√£o. No caso do problema de empacotamento 3D, a aptid√£o pode ser medida como o n√∫mero de compartimentos utilizados ou o espa√ßo desperdi√ßado nos compartimentos.
</li>
<li>
Sele√ß√£o: Selecione os indiv√≠duos da popula√ß√£o atual com base em sua aptid√£o. Os indiv√≠duos com melhor aptid√£o t√™m maior probabilidade de serem selecionados.
</li>
<li>
Cruzamento: Combine os indiv√≠duos selecionados para criar novas solu√ß√µes candidatas. No BRKGA, isso √© feito combinando as chaves aleat√≥rias enviesadas dos pais para gerar chaves para a prole.
</li>
<li>
Muta√ß√£o: Introduza pequenas perturba√ß√µes nas solu√ß√µes candidatas rec√©m-criadas. Isso √© feito alterando aleatoriamente algumas das chaves enviesadas.
</li>
<li>
Atualiza√ß√£o da popula√ß√£o: Substitua uma parte da popula√ß√£o atual pelas novas solu√ß√µes candidatas geradas.
</li>
<li>
Condi√ß√£o de parada: Verifique se a condi√ß√£o de parada foi atingida, como um n√∫mero m√°ximo de gera√ß√µes ou um limite de tempo.
</li>
<li>
Se a condi√ß√£o de parada n√£o for atingida, volte ao passo 2.
</li>
<li>
Retorne a melhor solu√ß√£o encontrada.
</li>
</ol>
<p>
O BRKGA para o problema de empacotamento 3D √© uma abordagem heur√≠stica que pode fornecer solu√ß√µes de alta qualidade em um tempo razo√°vel. No entanto, como outros algoritmos gen√©ticos, ele n√£o garante encontrar a solu√ß√£o √≥tima global em todos os casos.
</p>
<h2>
Na Pr√°tica
</h2>
<ol>
<li>
Defina os produtos e suas quantidades, como no exemplo fornecido:
</li>
</ol>
<pre spellcheck="false">python

Copy code
products = [ {"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)}, {"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)}, {"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)} ]
</pre>
<ol>
<li>
Implemente o algoritmo BRKGA, adaptando-o para o problema de empacotamento 3D. Isso inclui a defini√ß√£o de fun√ß√µes de aptid√£o (fitness), cruzamento (crossover) e muta√ß√£o espec√≠ficas para este problema. Voc√™ pode usar bibliotecas de algoritmos gen√©ticos em Python, como DEAP (
<a href="https://deap.readthedocs.io/en/master/" target="_blank">
https://deap.readthedocs.io/en/master/
</a>
) ou PyGMO (
<a href="https://esa.github.io/pygmo2/" target="_blank">
https://esa.github.io/pygmo2/
</a>
), para facilitar a implementa√ß√£o.
</li>
<li>
Configure os par√¢metros do algoritmo, como o tamanho da popula√ß√£o, o n√∫mero m√°ximo de gera√ß√µes, a taxa de cruzamento e a taxa de muta√ß√£o. Ajuste esses par√¢metros de acordo com suas necessidades de desempenho e qualidade da solu√ß√£o.
</li>
<li>
Execute o algoritmo BRKGA com os produtos e par√¢metros definidos. O algoritmo explorar√° v√°rias solu√ß√µes de empacotamento e tentar√° minimizar o n√∫mero de caixas necess√°rias para acomodar todos os itens.
</li>
<li>
Obtenha a melhor solu√ß√£o encontrada pelo algoritmo. Essa solu√ß√£o representar√° o tamanho m√≠nimo da caixa de papel√£o necess√°ria para acomodar todos os itens, considerando a abordagem heur√≠stica do BRKGA.
</li>
</ol>
<figure class="slate-resizable-image-embed slate-image-embed__resize-full-width">
<div>
</div>
<div>
</div>
<img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHbzxCaOtl3bA" src="https://media.licdn.com/dms/image/D4D12AQHbzxCaOtl3bA/article-inline_image-shrink_400_744/0/1679147821539?e=1691625600&amp;v=beta&amp;t=Gyvf6stCa-Alghc69Sn1fcK2U1hCkY7HRoMXcbeieEw" />
</figure>
<h3>
Exemplo
</h3>
<p>
Aqui est√° um exemplo simplificado de como implementar o
<strong>
BRKGA
</strong>
para o problema de empacotamento 3D usando a biblioteca
<strong>
DEAP
</strong>
em Python:
</p>
<pre spellcheck="false">import rando
from deap import base, creator, tools


# Defina os produtos e suas quantidades
products = [
{"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)},
{"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)},
{"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)}
]


# Fun√ß√£o de aptid√£o (fitness)
def fitness(individual):
# Aqui, voc√™ deve implementar a fun√ß√£o de aptid√£o que avalia a qualidade do empacotamento
# com base no indiv√≠duo (representando uma solu√ß√£o de empacotamento)
pass


# Fun√ß√£o de cruzamento (crossover)
def crossover(ind1, ind2):
# Aqui, voc√™ deve implementar a fun√ß√£o de cruzamento que combina dois indiv√≠duos
# para criar novos indiv√≠duos (descendentes)
pass


# Fun√ß√£o de muta√ß√£o
def mutate(individual):
# Aqui, voc√™ deve implementar a fun√ß√£o de muta√ß√£o que introduz pequenas perturba√ß√µes
# em um indiv√≠duo
pass


# Cria√ß√£o de tipos personalizados
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)


# Inicializa√ß√£o
toolbox = base.Toolbox()
toolbox.register("attr_float", random.random)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=len(products))
toolbox.register("population", tools.initRepeat, list, toolbox.individual)


# Registro de operadores gen√©ticos
toolbox.register("evaluate", fitness)
toolbox.register("mate", crossover)
toolbox.register("mutate", mutate)
toolbox.register("select", tools.selBest)


# Par√¢metros
POP_SIZE = 100
N_GEN = 100
CX_PB = 0.8
MUT_PB = 0.2


# Algoritmo principal
def main():
pop = toolbox.population(n=POP_SIZE)
hof = tools.HallOfFame(1)


stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", numpy.mean)
stats.register("min", numpy.min)
stats.register("max", numpy.max)


pop, log = algorithms.eaSimple(pop, toolbox, cxpb=CX_PB, mutpb=MUT_PB, ngen=N_GEN,
stats=stats, halloffame=hof, verbose=True)

return hof[0]


if __name__ == "__main__":
best_solution = main()
print("Melhor solu√ß√£o encontrada:", best_solution)


</pre>
<p>
Neste exemplo voc√™ precisar√° adaptar as fun√ß√µes fitness, crossover e mutate com base na representa√ß√£o e na estrat√©gia de empacotamento e vale voc√™ esplorar informa√ß√µes sobre como usar a biblioteca DEAP e adaptar este exemplo ao seu problema espec√≠fico.
</p>
<h3>
Uma solu√ß√£o simples para o empacotamento
</h3>
<p>
Usando algo mais simples, vou compartilhar um AWS Lambda escrito em python com a implementa√ß√£o da
<a href="https://pypi.org/project/py3dbp/" target="_blank">
Biblioteca py3dbp
</a>
:
</p>
<pre spellcheck="false">#!/usr/bin/env python3
import logging
from py3dbp import Packer, Bin, Item


# Configurar o logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)


# Isso configura o logger para exibir informa√ß√µes do log no console com um formato que inclui a data, a hora e o n√≠vel de log
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


def lambda_handler(event=None, context=None):
logger.info("Iniciando o algoritmo de empacotamento")


# Crie um Packer
packer = Packer()


bins_info = [
("Caixa A", 10, 10, 10, 0),
("Caixa B", 12, 12, 11, 0),
("Caixa C", 15, 12, 11, 0),
("Caixa D", 20, 15, 12, 0),
("Caixa E", 25, 20, 15, 0),
("Caixa F", 30, 30, 15, 0),
("Caixa G", 40, 35, 20, 0),
("Caixa H", 50, 45, 30, 0),
("Caixa I", 300, 300, 300, 0),
("Caixa J", 1500, 1500, 1500, 0)
]


for bin_info in bins_info:
packer.add_bin(Bin(*bin_info))
logger.info(f"Adicionando caixa: {bin_info}")


# Defina os produtos e suas quantidades
products = [
{"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)},
{"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)},
{"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)}
]


# Adicione os produtos como itens
for product in products:
for _ in range(product["quantity"]):
packer.add_item(Item(product["name"], *product["dimensions"], 0))
logger.info(f"Adicionando item: {product}")


# Execute o algoritmo de empacotamento
packer.pack()


# Qual seria uma caixa grande o suficiente para conter todos os itens?
ideal_bin = {
"max_width": sum(item.width for item in packer.items),
"max_depth": sum(item.depth for item in packer.items),
"max_height": sum(item.height for item in packer.items)
}
logger.info(f"Caixa ideal: {ideal_bin}")


# Encontre a caixa com o menor volume poss√≠vel
for b in packer.bins:
if len(b.items) &gt; 0 and len(b.unfitted_items) == 0:
best_bin = b
break

# Retorne o resultado
response = {
"statusCode": 200,
"body": {
"melhor caixa": best_bin.name,
"width": best_bin.width,
"depth": best_bin.depth,
"height": best_bin.height
}
}

logger.info(f"Resposta: {response}")
return response


if __name__ == "__main__":
lambda_handler()


</pre>
<p>
O script acima d√° o seguinte output:
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Iniciando o algoritmo de empacotamento
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa A', 10, 10, 10, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa B', 12, 12, 11, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa C', 15, 12, 11, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa D', 20, 15, 12, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa E', 25, 20, 15, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa F', 30, 30, 15, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa G', 40, 35, 20, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa H', 50, 45, 30, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa I', 300, 300, 300, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa J', 1500, 1500, 1500, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Alpha', 'quantity': 10, 'dimensions': (10, 10, 10)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Bravo', 'quantity': 1, 'dimensions': (150, 200, 140)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Charlie', 'quantity': 3, 'dimensions': (15, 20, 14)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,978 - INFO -
</em>
<strong>
<em>
Caixa ideal: {'max_width': Decimal('295.000'), 'max_depth': Decimal('282.000'), 'max_height': Decimal('360.000')}
</em>
</strong>
</p>
<p>
<em>
2023-03-24 15:13:57,978 - INFO - Resposta: {'statusCode': 200, 'body': {'melhor caixa': 'Caixa I', 'width': Decimal('300.000'), 'depth': Decimal('300.000'), 'height': Decimal('300.000')}}
</em>
</p>
<p>
<br />
</p>
<h3>
Explore mais
</h3>
<ol>
<li>
<a href="https://delta1epsilon.github.io/2016/3D-bin-packing-problem-in-R/" target="_blank">
3D bin packing problem in R
</a>
</li>
<li>
<a href="https://github.com/dasvision0212/3D-Bin-Packing-Problem-with-BRKGA" target="_blank">
Tutorial of BRKGA for 3D-Bin Packing Problem
</a>
</li>
<li>
<a href="https://pypi.org/project/py3dbp/" target="_blank">
Biblioteca py3dbp
</a>
- 3D Bin Packing
</li>
<li>
<a href="https://developers.google.com/optimization/pack/bin_packing" target="_blank">
The Bin Packing Problem
</a>
</li>
</ol>
<div>
<hr />
</div>
<p>
J√° resolveu esse problema de outras formas? Me conta!
</p>
</div>

  </div><a class="u-url" href="/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
          <a href="https://www.gpupo.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>RSS</span>
          </a><a class="page-link" href="/">üìù Artigos</a><a class="page-link" href="/updates/">üí¨Updates</a><a class="page-link" href="/readme/">üõ†Ô∏èComo fiz esse site</a></div>
    </div>


  </div>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <a class="libutton"
          href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">Subscribe on LinkedIn</a>
        <div class="newsletter-text">
        üì∞ <a href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">NEWSLETTER</a>
          <b>Bora Gil RePensar</b>:
          <i>Repense comigo temas relacionados √† inova√ß√£o, e-commerce e tecnologia</i>
        </div>
      </div>
    </div>
  </div>
</footer></body>

</html>
