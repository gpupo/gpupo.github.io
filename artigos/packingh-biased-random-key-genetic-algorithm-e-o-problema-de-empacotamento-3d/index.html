<!DOCTYPE html>
<html lang="pt-BR"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D | Gilmar Pupo</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D" />
<meta property="og:locale" content="pt_BR" />
<meta name="description" content="Imagina que você tem um kit de produtos e quer saber qual o tamanho da caixa que você precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma única coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D é uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D é uma abordagem baseada em algoritmos genéticos para resolver problemas de otimização de empacotamento tridimensional. O objetivo do problema de empacotamento 3D é colocar um conjunto de itens com dimensões tridimensionais (comprimento, largura e altura) em um número mínimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA é uma classe de algoritmos genéticos que utiliza chaves aleatórias enviesadas para representar soluções. O algoritmo genético é uma técnica de busca heurística inspirada no processo de evolução natural. Ele trabalha com uma população de soluções candidatas (indivíduos), onde cada indivíduo representa uma solução potencial para o problema. Essas soluções evoluem ao longo do tempo por meio de operações como seleção, cruzamento (recombinação) e mutação. Aqui está uma descrição geral do BRKGA para o problema de empacotamento 3D: Inicialização: Gere uma população inicial de soluções candidatas aleatórias, representadas por chaves aleatórias enviesadas. Avaliação: Calcule a aptidão (fitness) de cada indivíduo na população. No caso do problema de empacotamento 3D, a aptidão pode ser medida como o número de compartimentos utilizados ou o espaço desperdiçado nos compartimentos. Seleção: Selecione os indivíduos da população atual com base em sua aptidão. Os indivíduos com melhor aptidão têm maior probabilidade de serem selecionados. Cruzamento: Combine os indivíduos selecionados para criar novas soluções candidatas. No BRKGA, isso é feito combinando as chaves aleatórias enviesadas dos pais para gerar chaves para a prole. Mutação: Introduza pequenas perturbações nas soluções candidatas recém-criadas. Isso é feito alterando aleatoriamente algumas das chaves enviesadas. Atualização da população: Substitua uma parte da população atual pelas novas soluções candidatas geradas. Condição de parada: Verifique se a condição de parada foi atingida, como um número máximo de gerações ou um limite de tempo. Se a condição de parada não for atingida, volte ao passo 2. Retorne a melhor solução encontrada. O BRKGA para o problema de empacotamento 3D é uma abordagem heurística que pode fornecer soluções de alta qualidade em um tempo razoável. No entanto, como outros algoritmos genéticos, ele não garante encontrar a solução ótima global em todos os casos. Na Prática Defina os produtos e suas quantidades, como no exemplo fornecido: python" />
<meta property="og:description" content="Imagina que você tem um kit de produtos e quer saber qual o tamanho da caixa que você precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma única coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D é uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D é uma abordagem baseada em algoritmos genéticos para resolver problemas de otimização de empacotamento tridimensional. O objetivo do problema de empacotamento 3D é colocar um conjunto de itens com dimensões tridimensionais (comprimento, largura e altura) em um número mínimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA é uma classe de algoritmos genéticos que utiliza chaves aleatórias enviesadas para representar soluções. O algoritmo genético é uma técnica de busca heurística inspirada no processo de evolução natural. Ele trabalha com uma população de soluções candidatas (indivíduos), onde cada indivíduo representa uma solução potencial para o problema. Essas soluções evoluem ao longo do tempo por meio de operações como seleção, cruzamento (recombinação) e mutação. Aqui está uma descrição geral do BRKGA para o problema de empacotamento 3D: Inicialização: Gere uma população inicial de soluções candidatas aleatórias, representadas por chaves aleatórias enviesadas. Avaliação: Calcule a aptidão (fitness) de cada indivíduo na população. No caso do problema de empacotamento 3D, a aptidão pode ser medida como o número de compartimentos utilizados ou o espaço desperdiçado nos compartimentos. Seleção: Selecione os indivíduos da população atual com base em sua aptidão. Os indivíduos com melhor aptidão têm maior probabilidade de serem selecionados. Cruzamento: Combine os indivíduos selecionados para criar novas soluções candidatas. No BRKGA, isso é feito combinando as chaves aleatórias enviesadas dos pais para gerar chaves para a prole. Mutação: Introduza pequenas perturbações nas soluções candidatas recém-criadas. Isso é feito alterando aleatoriamente algumas das chaves enviesadas. Atualização da população: Substitua uma parte da população atual pelas novas soluções candidatas geradas. Condição de parada: Verifique se a condição de parada foi atingida, como um número máximo de gerações ou um limite de tempo. Se a condição de parada não for atingida, volte ao passo 2. Retorne a melhor solução encontrada. O BRKGA para o problema de empacotamento 3D é uma abordagem heurística que pode fornecer soluções de alta qualidade em um tempo razoável. No entanto, como outros algoritmos genéticos, ele não garante encontrar a solução ótima global em todos os casos. Na Prática Defina os produtos e suas quantidades, como no exemplo fornecido: python" />
<link rel="canonical" href="https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" />
<meta property="og:url" content="https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" />
<meta property="og:site_name" content="Gilmar Pupo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-18T13:46:00-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-18T13:46:00-03:00","datePublished":"2023-03-18T13:46:00-03:00","description":"Imagina que você tem um kit de produtos e quer saber qual o tamanho da caixa que você precisa. Um algoritmo simples pode facilmente empilhar todos os produtos em uma única coluna e atrapalhar os seus planos, certo? Aplicar o BRKGA (Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D é uma alternativa. Teoria O BRKGA (Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D é uma abordagem baseada em algoritmos genéticos para resolver problemas de otimização de empacotamento tridimensional. O objetivo do problema de empacotamento 3D é colocar um conjunto de itens com dimensões tridimensionais (comprimento, largura e altura) em um número mínimo de compartimentos (ou caixas) com capacidades limitadas. O BRKGA é uma classe de algoritmos genéticos que utiliza chaves aleatórias enviesadas para representar soluções. O algoritmo genético é uma técnica de busca heurística inspirada no processo de evolução natural. Ele trabalha com uma população de soluções candidatas (indivíduos), onde cada indivíduo representa uma solução potencial para o problema. Essas soluções evoluem ao longo do tempo por meio de operações como seleção, cruzamento (recombinação) e mutação. Aqui está uma descrição geral do BRKGA para o problema de empacotamento 3D: Inicialização: Gere uma população inicial de soluções candidatas aleatórias, representadas por chaves aleatórias enviesadas. Avaliação: Calcule a aptidão (fitness) de cada indivíduo na população. No caso do problema de empacotamento 3D, a aptidão pode ser medida como o número de compartimentos utilizados ou o espaço desperdiçado nos compartimentos. Seleção: Selecione os indivíduos da população atual com base em sua aptidão. Os indivíduos com melhor aptidão têm maior probabilidade de serem selecionados. Cruzamento: Combine os indivíduos selecionados para criar novas soluções candidatas. No BRKGA, isso é feito combinando as chaves aleatórias enviesadas dos pais para gerar chaves para a prole. Mutação: Introduza pequenas perturbações nas soluções candidatas recém-criadas. Isso é feito alterando aleatoriamente algumas das chaves enviesadas. Atualização da população: Substitua uma parte da população atual pelas novas soluções candidatas geradas. Condição de parada: Verifique se a condição de parada foi atingida, como um número máximo de gerações ou um limite de tempo. Se a condição de parada não for atingida, volte ao passo 2. Retorne a melhor solução encontrada. O BRKGA para o problema de empacotamento 3D é uma abordagem heurística que pode fornecer soluções de alta qualidade em um tempo razoável. No entanto, como outros algoritmos genéticos, ele não garante encontrar a solução ótima global em todos os casos. Na Prática Defina os produtos e suas quantidades, como no exemplo fornecido: python","headline":"Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/"},"url":"https://www.gpupo.com/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.gpupo.com/feed.xml" title="Gilmar Pupo" /><script async src="https://www.googletagmanager.com/gtag/js?id=383379184"></script>
<script>
  window['ga-disable-383379184'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '383379184');
</script>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Gilmar Pupo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/">📝 Artigos</a><a class="page-link" href="/lessons/">🧾 Aulas</a><a class="page-link" href="/livros/">📚Livros</a><a class="page-link" href="/about/">📜 About</a><a class="page-link" href="/updates/">💬Updates</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Packing- Biased Random-Key Genetic Algorithm e o problema de empacotamento 3D</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-03-18T13:46:00-03:00" itemprop="datePublished">
        Mar 18, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div>
<p>
Imagina que você tem um kit de produtos e quer saber qual o tamanho da caixa que você precisa. Um algoritmo simples pode facilmente
<strong>
empilhar todos os produtos em uma única coluna
</strong>
e atrapalhar os seus planos, certo?
</p>
<p>
Aplicar o
<strong>
BRKGA
</strong>
(Biased Random-Key Genetic Algorithm) para resolver o problema de empacotamento 3D é uma alternativa.
</p>
<figure class="slate-resizable-image-embed slate-image-embed__resize-full-width">
<div>
</div>
<div>
</div>
<img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQE3T_OBnXpR1w" src="https://media.licdn.com/dms/image/D4D12AQE3T_OBnXpR1w/article-inline_image-shrink_1000_1488/0/1679147721879?e=1691625600&amp;v=beta&amp;t=6085Ctij9uEemKRXMS8HixhIrDk8IV-TunfnBRN4Oj8" />
</figure>
<h2>
Teoria
</h2>
<p>
O
<strong>
BRKGA
</strong>
(Biased Random-Key Genetic Algorithm) para o Problema de Empacotamento 3D é uma abordagem baseada em algoritmos genéticos para resolver problemas de otimização de empacotamento tridimensional. O objetivo do problema de empacotamento 3D é colocar um conjunto de itens com dimensões tridimensionais (comprimento, largura e altura) em um número mínimo de compartimentos (ou caixas) com capacidades limitadas.
</p>
<p>
O BRKGA é uma classe de algoritmos genéticos que utiliza chaves aleatórias enviesadas para representar soluções. O algoritmo genético é uma técnica de busca heurística inspirada no processo de evolução natural. Ele trabalha com uma população de soluções candidatas (indivíduos), onde cada indivíduo representa uma solução potencial para o problema. Essas soluções evoluem ao longo do tempo por meio de operações como seleção, cruzamento (recombinação) e mutação.
</p>
<p>
Aqui está uma descrição geral do BRKGA para o problema de empacotamento 3D:
</p>
<ol>
<li>
Inicialização: Gere uma população inicial de soluções candidatas aleatórias, representadas por chaves aleatórias enviesadas.
</li>
<li>
Avaliação: Calcule a aptidão (fitness) de cada indivíduo na população. No caso do problema de empacotamento 3D, a aptidão pode ser medida como o número de compartimentos utilizados ou o espaço desperdiçado nos compartimentos.
</li>
<li>
Seleção: Selecione os indivíduos da população atual com base em sua aptidão. Os indivíduos com melhor aptidão têm maior probabilidade de serem selecionados.
</li>
<li>
Cruzamento: Combine os indivíduos selecionados para criar novas soluções candidatas. No BRKGA, isso é feito combinando as chaves aleatórias enviesadas dos pais para gerar chaves para a prole.
</li>
<li>
Mutação: Introduza pequenas perturbações nas soluções candidatas recém-criadas. Isso é feito alterando aleatoriamente algumas das chaves enviesadas.
</li>
<li>
Atualização da população: Substitua uma parte da população atual pelas novas soluções candidatas geradas.
</li>
<li>
Condição de parada: Verifique se a condição de parada foi atingida, como um número máximo de gerações ou um limite de tempo.
</li>
<li>
Se a condição de parada não for atingida, volte ao passo 2.
</li>
<li>
Retorne a melhor solução encontrada.
</li>
</ol>
<p>
O BRKGA para o problema de empacotamento 3D é uma abordagem heurística que pode fornecer soluções de alta qualidade em um tempo razoável. No entanto, como outros algoritmos genéticos, ele não garante encontrar a solução ótima global em todos os casos.
</p>
<h2>
Na Prática
</h2>
<ol>
<li>
Defina os produtos e suas quantidades, como no exemplo fornecido:
</li>
</ol>
<pre spellcheck="false">python

Copy code
products = [ {"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)}, {"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)}, {"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)} ]
</pre>
<ol>
<li>
Implemente o algoritmo BRKGA, adaptando-o para o problema de empacotamento 3D. Isso inclui a definição de funções de aptidão (fitness), cruzamento (crossover) e mutação específicas para este problema. Você pode usar bibliotecas de algoritmos genéticos em Python, como DEAP (
<a href="https://deap.readthedocs.io/en/master/" target="_blank">
https://deap.readthedocs.io/en/master/
</a>
) ou PyGMO (
<a href="https://esa.github.io/pygmo2/" target="_blank">
https://esa.github.io/pygmo2/
</a>
), para facilitar a implementação.
</li>
<li>
Configure os parâmetros do algoritmo, como o tamanho da população, o número máximo de gerações, a taxa de cruzamento e a taxa de mutação. Ajuste esses parâmetros de acordo com suas necessidades de desempenho e qualidade da solução.
</li>
<li>
Execute o algoritmo BRKGA com os produtos e parâmetros definidos. O algoritmo explorará várias soluções de empacotamento e tentará minimizar o número de caixas necessárias para acomodar todos os itens.
</li>
<li>
Obtenha a melhor solução encontrada pelo algoritmo. Essa solução representará o tamanho mínimo da caixa de papelão necessária para acomodar todos os itens, considerando a abordagem heurística do BRKGA.
</li>
</ol>
<figure class="slate-resizable-image-embed slate-image-embed__resize-full-width">
<div>
</div>
<div>
</div>
<img alt="No alt text provided for this image" data-media-urn="urn:li:digitalmediaAsset:D4D12AQHbzxCaOtl3bA" src="https://media.licdn.com/dms/image/D4D12AQHbzxCaOtl3bA/article-inline_image-shrink_400_744/0/1679147821539?e=1691625600&amp;v=beta&amp;t=Gyvf6stCa-Alghc69Sn1fcK2U1hCkY7HRoMXcbeieEw" />
</figure>
<h3>
Exemplo
</h3>
<p>
Aqui está um exemplo simplificado de como implementar o
<strong>
BRKGA
</strong>
para o problema de empacotamento 3D usando a biblioteca
<strong>
DEAP
</strong>
em Python:
</p>
<pre spellcheck="false">import rando
from deap import base, creator, tools


# Defina os produtos e suas quantidades
products = [
{"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)},
{"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)},
{"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)}
]


# Função de aptidão (fitness)
def fitness(individual):
# Aqui, você deve implementar a função de aptidão que avalia a qualidade do empacotamento
# com base no indivíduo (representando uma solução de empacotamento)
pass


# Função de cruzamento (crossover)
def crossover(ind1, ind2):
# Aqui, você deve implementar a função de cruzamento que combina dois indivíduos
# para criar novos indivíduos (descendentes)
pass


# Função de mutação
def mutate(individual):
# Aqui, você deve implementar a função de mutação que introduz pequenas perturbações
# em um indivíduo
pass


# Criação de tipos personalizados
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)


# Inicialização
toolbox = base.Toolbox()
toolbox.register("attr_float", random.random)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=len(products))
toolbox.register("population", tools.initRepeat, list, toolbox.individual)


# Registro de operadores genéticos
toolbox.register("evaluate", fitness)
toolbox.register("mate", crossover)
toolbox.register("mutate", mutate)
toolbox.register("select", tools.selBest)


# Parâmetros
POP_SIZE = 100
N_GEN = 100
CX_PB = 0.8
MUT_PB = 0.2


# Algoritmo principal
def main():
pop = toolbox.population(n=POP_SIZE)
hof = tools.HallOfFame(1)


stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("avg", numpy.mean)
stats.register("min", numpy.min)
stats.register("max", numpy.max)


pop, log = algorithms.eaSimple(pop, toolbox, cxpb=CX_PB, mutpb=MUT_PB, ngen=N_GEN,
stats=stats, halloffame=hof, verbose=True)

return hof[0]


if __name__ == "__main__":
best_solution = main()
print("Melhor solução encontrada:", best_solution)


</pre>
<p>
Neste exemplo você precisará adaptar as funções fitness, crossover e mutate com base na representação e na estratégia de empacotamento e vale você esplorar informações sobre como usar a biblioteca DEAP e adaptar este exemplo ao seu problema específico.
</p>
<h3>
Uma solução simples para o empacotamento
</h3>
<p>
Usando algo mais simples, vou compartilhar um AWS Lambda escrito em python com a implementação da
<a href="https://pypi.org/project/py3dbp/" target="_blank">
Biblioteca py3dbp
</a>
:
</p>
<pre spellcheck="false">#!/usr/bin/env python3
import logging
from py3dbp import Packer, Bin, Item


# Configurar o logger
logger = logging.getLogger()
logger.setLevel(logging.INFO)


# Isso configura o logger para exibir informações do log no console com um formato que inclui a data, a hora e o nível de log
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


def lambda_handler(event=None, context=None):
logger.info("Iniciando o algoritmo de empacotamento")


# Crie um Packer
packer = Packer()


bins_info = [
("Caixa A", 10, 10, 10, 0),
("Caixa B", 12, 12, 11, 0),
("Caixa C", 15, 12, 11, 0),
("Caixa D", 20, 15, 12, 0),
("Caixa E", 25, 20, 15, 0),
("Caixa F", 30, 30, 15, 0),
("Caixa G", 40, 35, 20, 0),
("Caixa H", 50, 45, 30, 0),
("Caixa I", 300, 300, 300, 0),
("Caixa J", 1500, 1500, 1500, 0)
]


for bin_info in bins_info:
packer.add_bin(Bin(*bin_info))
logger.info(f"Adicionando caixa: {bin_info}")


# Defina os produtos e suas quantidades
products = [
{"name": "Alpha", "quantity": 10, "dimensions": (10, 10, 10)},
{"name": "Bravo", "quantity": 1, "dimensions": (150, 200, 140)},
{"name": "Charlie", "quantity": 3, "dimensions": (15, 20, 14)}
]


# Adicione os produtos como itens
for product in products:
for _ in range(product["quantity"]):
packer.add_item(Item(product["name"], *product["dimensions"], 0))
logger.info(f"Adicionando item: {product}")


# Execute o algoritmo de empacotamento
packer.pack()


# Qual seria uma caixa grande o suficiente para conter todos os itens?
ideal_bin = {
"max_width": sum(item.width for item in packer.items),
"max_depth": sum(item.depth for item in packer.items),
"max_height": sum(item.height for item in packer.items)
}
logger.info(f"Caixa ideal: {ideal_bin}")


# Encontre a caixa com o menor volume possível
for b in packer.bins:
if len(b.items) &gt; 0 and len(b.unfitted_items) == 0:
best_bin = b
break

# Retorne o resultado
response = {
"statusCode": 200,
"body": {
"melhor caixa": best_bin.name,
"width": best_bin.width,
"depth": best_bin.depth,
"height": best_bin.height
}
}

logger.info(f"Resposta: {response}")
return response


if __name__ == "__main__":
lambda_handler()


</pre>
<p>
O script acima dá o seguinte output:
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Iniciando o algoritmo de empacotamento
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa A', 10, 10, 10, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa B', 12, 12, 11, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa C', 15, 12, 11, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa D', 20, 15, 12, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa E', 25, 20, 15, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa F', 30, 30, 15, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa G', 40, 35, 20, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa H', 50, 45, 30, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa I', 300, 300, 300, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando caixa: ('Caixa J', 1500, 1500, 1500, 0)
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Alpha', 'quantity': 10, 'dimensions': (10, 10, 10)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Bravo', 'quantity': 1, 'dimensions': (150, 200, 140)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,969 - INFO - Adicionando item: {'name': 'Charlie', 'quantity': 3, 'dimensions': (15, 20, 14)}
</em>
</p>
<p>
<em>
2023-03-24 15:13:57,978 - INFO -
</em>
<strong>
<em>
Caixa ideal: {'max_width': Decimal('295.000'), 'max_depth': Decimal('282.000'), 'max_height': Decimal('360.000')}
</em>
</strong>
</p>
<p>
<em>
2023-03-24 15:13:57,978 - INFO - Resposta: {'statusCode': 200, 'body': {'melhor caixa': 'Caixa I', 'width': Decimal('300.000'), 'depth': Decimal('300.000'), 'height': Decimal('300.000')}}
</em>
</p>
<p>
<br />
</p>
<h3>
Explore mais
</h3>
<ol>
<li>
<a href="https://delta1epsilon.github.io/2016/3D-bin-packing-problem-in-R/" target="_blank">
3D bin packing problem in R
</a>
</li>
<li>
<a href="https://github.com/dasvision0212/3D-Bin-Packing-Problem-with-BRKGA" target="_blank">
Tutorial of BRKGA for 3D-Bin Packing Problem
</a>
</li>
<li>
<a href="https://pypi.org/project/py3dbp/" target="_blank">
Biblioteca py3dbp
</a>
- 3D Bin Packing
</li>
<li>
<a href="https://developers.google.com/optimization/pack/bin_packing" target="_blank">
The Bin Packing Problem
</a>
</li>
</ol>
<div>
<hr />
</div>
<p>
Já resolveu esse problema de outras formas? Me conta!
</p>
</div>

  </div><a class="u-url" href="/artigos/packingh-biased-random-key-genetic-algorithm-e-o-problema-de-empacotamento-3d/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
          <a href="https://www.gpupo.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>RSS</span>
          </a><a class="page-link" href="/">📝 Artigos</a><a class="page-link" href="/updates/">💬Updates</a><a class="page-link" href="/readme/">🛠️Como fiz esse site</a></div>
    </div>


  </div>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <a class="libutton"
          href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">Subscribe on LinkedIn</a>
        <div class="newsletter-text">
        📰 <a href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">NEWSLETTER</a>
          <b>Bora Gil RePensar</b>:
          <i>Repense comigo temas relacionados à inovação, e-commerce e tecnologia</i>
        </div>
      </div>
    </div>
  </div>
</footer></body>

</html>
