<!DOCTYPE html>
<html lang="pt-BR"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Code Rot, Complexidade Ciclom√°tica e a Qualidade de c√≥digo | Gilmar Pupo</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Code Rot, Complexidade Ciclom√°tica e a Qualidade de c√≥digo" />
<meta property="og:locale" content="pt_BR" />
<meta name="description" content="Vamos falar da ferrugem do software ? O termo &quot; code rot &quot; descreve a deteriora√ß√£o gradual da qualidade do c√≥digo em um software ao longo do tempo. Esse problema √© comum em projetos de longo prazo, onde muitas pessoas trabalham em diferentes partes do c√≥digo sem se preocupar com a qualidade geral do projeto. A principal causa do &quot;code rot&quot; √© a falta de aten√ß√£o aos detalhes e √† qualidade do c√≥digo. Muitas vezes, as mudan√ßas no c√≥digo s√£o feitas sem considerar o impacto no restante do projeto, o que pode levar a problemas de compatibilidade e complexidade desnecess√°ria. Com o tempo, essas pequenas mudan√ßas se acumulam e resultam em um c√≥digo dif√≠cil de entender, manter e evoluir. Para evitar o &quot;code rot&quot;, √© importante estabelecer padr√µes de qualidade para o c√≥digo. Uma das formas mais eficazes de fazer isso √© por meio de limites e acordos. Por exemplo, a complexidade ciclom√°tica pode ser usada para definir um limite para a complexidade do c√≥digo. A complexidade ciclom√°tica √© uma medida da complexidade estrutural do c√≥digo, e √© definida como o n√∫mero de caminhos independentes em um programa. Limitar a complexidade ciclom√°tica a um n√≠vel aceit√°vel pode ajudar a manter o c√≥digo leg√≠vel e f√°cil de entender. Complexidade ciclom√°tica √© uma medida num√©rica que indica a complexidade de um programa de software. A complexidade ciclom√°tica mede o n√∫mero de caminhos distintos que um programa pode seguir durante sua execu√ß√£o. Isso inclui caminhos de decis√£o em condicionais, loops e estruturas de controle de fluxo. A complexidade ciclom√°tica √© calculada a partir do grafo de fluxo de controle do programa. O grafo de fluxo de controle √© um diagrama que representa graficamente as diferentes decis√µes, loops e estruturas de controle de fluxo de um programa. A partir desse diagrama, a complexidade ciclom√°tica pode ser calculada contando o n√∫mero de regi√µes conectadas, que correspondem ao n√∫mero de caminhos independentes que podem ser percorridos atrav√©s do c√≥digo. Uma alta complexidade ciclom√°tica pode indicar que um programa √© dif√≠cil de entender, manter e testar. Isso ocorre porque o programa tem muitos caminhos poss√≠veis de execu√ß√£o, aumentando a chance de erros e tornando o c√≥digo dif√≠cil de compreender. A complexidade ciclom√°tica tamb√©m pode indicar √°reas do c√≥digo que precisam ser reestruturadas para melhorar sua qualidade e legibilidade. A complexidade ciclom√°tica pode ser usada para estabelecer limites no c√≥digo e ajudar os desenvolvedores a escrever programas mais claros e leg√≠veis. Por exemplo, algumas equipes de desenvolvimento estabelecem um limite m√°ximo de complexidade ciclom√°tica para cada fun√ß√£o ou m√©todo. Quando um m√©todo excede esse limite, ele √© considerado complexo demais e precisa ser reescrito ou dividido em fun√ß√µes menores. Vamos considerar o seguinte c√≥digo de exemplo em Python: def calcula_idade(nome, ano_nascimento): ano_atual = 2023 idade = ano_atual - ano_nascimento print(nome, &quot;tem&quot;, idade, &quot;anos.&quot;) if idade &gt;= 18: print(&quot;Voc√™ j√° √© maior de idade.&quot;) else: print(&quot;Voc√™ ainda n√£o √© maior de idade.&quot;) Para calcular a complexidade ciclom√°tica deste c√≥digo, precisamos construir o grafo de fluxo de controle. Cada decis√£o, loop ou estrutura de controle de fluxo adiciona uma regi√£o conectada ao grafo, o que aumenta a complexidade ciclom√°tica. No caso deste c√≥digo, temos tr√™s estruturas de controle de fluxo: a declara√ß√£o de if , que tem dois poss√≠veis caminhos (um para a condi√ß√£o True e outro para a condi√ß√£o False ), e duas chamadas de fun√ß√£o print , que n√£o adicionam nenhuma regi√£o conectada ao grafo. Portanto, a complexidade ciclom√°tica deste c√≥digo √© 3. A complexidade ciclom√°tica pode ser √∫til para identificar se√ß√µes de c√≥digo que precisam ser simplificadas ou divididas em fun√ß√µes menores. Neste caso, a fun√ß√£o calcula_idade √© relativamente simples e n√£o √© necess√°rio dividi-la em partes menores. No entanto, se a fun√ß√£o tivesse mais estruturas de controle de fluxo, a complexidade ciclom√°tica seria maior e poderia indicar a necessidade de simplificar o c√≥digo ou dividi-lo em fun√ß√µes menores para facilitar sua compreens√£o e manuten√ß√£o. Outra estrat√©gia para escrever c√≥digo de qualidade √© seguir a regra &quot; 80/24 &quot;. Essa regra sugere que o c√≥digo deve ser escrito em uma caixa de 80 caracteres de largura e 24 linhas de altura. Essa pr√°tica ajuda a manter as fun√ß√µes e m√©todos pequenos e leg√≠veis, facilitando a compreens√£o e manuten√ß√£o do c√≥digo. Al√©m disso, √© importante prestar aten√ß√£o √† documenta√ß√£o do c√≥digo . Uma documenta√ß√£o adequada pode ajudar a garantir que o c√≥digo seja entendido e mantido ao longo do tempo. A documenta√ß√£o pode incluir coment√°rios no c√≥digo, manuais do usu√°rio, e documenta√ß√£o t√©cnica do sistema. Outra forma de evitar o &quot;code rot&quot; √© atrav√©s da revis√£o de c√≥digo. A revis√£o de c√≥digo √© uma t√©cnica em que um ou mais desenvolvedores revisam o c√≥digo de outros desenvolvedores antes de ser incorporado ao projeto. A revis√£o de c√≥digo ajuda a identificar problemas de qualidade no c√≥digo e a garantir que o c√≥digo esteja em conformidade com os padr√µes estabelecidos. Finalmente, √© importante que os desenvolvedores recebam treinamento adequado em boas pr√°ticas de desenvolvimento de software. Isso pode incluir aulas de programa√ß√£o, treinamento em ferramentas de desenvolvimento, e orienta√ß√£o sobre padr√µes de codifica√ß√£o e boas pr√°ticas. Aqui est√£o 10 autores e seus livros que abordam a import√¢ncia de escrever c√≥digo de qualidade e f√°cil de entender: Steve McConnell - Code Complete 2nd Edition Robert C. Martin - Clean Code: A Handbook of Agile Software Craftsmanship Martin Fowler - Refactoring: Improving the Design of Existing Code Joshua Bloch - Effective Java Eric Evans - Domain-Driven Design: Tackling Complexity in the Heart of Software Kent Beck - Test-Driven Development: By Example Michael Feathers - Working Effectively with Legacy Code Andrew Hunt e David Thomas - The Pragmatic Programmer: From Journeyman to Master Dan North - Accelerated Agile: Techniques for Directing Agile Development Jeff Atwood e Joel Spolsky - The Best Software Writing I: Selected and Introduced by Joel Spolsky O &quot;code rot&quot; √© um problema comum em projetos de longo prazo e pode ser evitado atrav√©s da ado√ß√£o de padr√µes de qualidade para o c√≥digo. Isso pode incluir limites na complexidade ciclom√°tica, a regra &quot;80/24&quot;, a documenta√ß√£o adequada, a revis√£o de c√≥digo, e o treinamento em boas pr√°ticas de desenvolvimento de software. Ao adotar essas pr√°ticas, os desenvolvedores podem garantir que o c√≥digo seja f√°cil de entender, manter e evoluir ao longo do tempo. Bora lubrificar esse c√≥digo!" />
<meta property="og:description" content="Vamos falar da ferrugem do software ? O termo &quot; code rot &quot; descreve a deteriora√ß√£o gradual da qualidade do c√≥digo em um software ao longo do tempo. Esse problema √© comum em projetos de longo prazo, onde muitas pessoas trabalham em diferentes partes do c√≥digo sem se preocupar com a qualidade geral do projeto. A principal causa do &quot;code rot&quot; √© a falta de aten√ß√£o aos detalhes e √† qualidade do c√≥digo. Muitas vezes, as mudan√ßas no c√≥digo s√£o feitas sem considerar o impacto no restante do projeto, o que pode levar a problemas de compatibilidade e complexidade desnecess√°ria. Com o tempo, essas pequenas mudan√ßas se acumulam e resultam em um c√≥digo dif√≠cil de entender, manter e evoluir. Para evitar o &quot;code rot&quot;, √© importante estabelecer padr√µes de qualidade para o c√≥digo. Uma das formas mais eficazes de fazer isso √© por meio de limites e acordos. Por exemplo, a complexidade ciclom√°tica pode ser usada para definir um limite para a complexidade do c√≥digo. A complexidade ciclom√°tica √© uma medida da complexidade estrutural do c√≥digo, e √© definida como o n√∫mero de caminhos independentes em um programa. Limitar a complexidade ciclom√°tica a um n√≠vel aceit√°vel pode ajudar a manter o c√≥digo leg√≠vel e f√°cil de entender. Complexidade ciclom√°tica √© uma medida num√©rica que indica a complexidade de um programa de software. A complexidade ciclom√°tica mede o n√∫mero de caminhos distintos que um programa pode seguir durante sua execu√ß√£o. Isso inclui caminhos de decis√£o em condicionais, loops e estruturas de controle de fluxo. A complexidade ciclom√°tica √© calculada a partir do grafo de fluxo de controle do programa. O grafo de fluxo de controle √© um diagrama que representa graficamente as diferentes decis√µes, loops e estruturas de controle de fluxo de um programa. A partir desse diagrama, a complexidade ciclom√°tica pode ser calculada contando o n√∫mero de regi√µes conectadas, que correspondem ao n√∫mero de caminhos independentes que podem ser percorridos atrav√©s do c√≥digo. Uma alta complexidade ciclom√°tica pode indicar que um programa √© dif√≠cil de entender, manter e testar. Isso ocorre porque o programa tem muitos caminhos poss√≠veis de execu√ß√£o, aumentando a chance de erros e tornando o c√≥digo dif√≠cil de compreender. A complexidade ciclom√°tica tamb√©m pode indicar √°reas do c√≥digo que precisam ser reestruturadas para melhorar sua qualidade e legibilidade. A complexidade ciclom√°tica pode ser usada para estabelecer limites no c√≥digo e ajudar os desenvolvedores a escrever programas mais claros e leg√≠veis. Por exemplo, algumas equipes de desenvolvimento estabelecem um limite m√°ximo de complexidade ciclom√°tica para cada fun√ß√£o ou m√©todo. Quando um m√©todo excede esse limite, ele √© considerado complexo demais e precisa ser reescrito ou dividido em fun√ß√µes menores. Vamos considerar o seguinte c√≥digo de exemplo em Python: def calcula_idade(nome, ano_nascimento): ano_atual = 2023 idade = ano_atual - ano_nascimento print(nome, &quot;tem&quot;, idade, &quot;anos.&quot;) if idade &gt;= 18: print(&quot;Voc√™ j√° √© maior de idade.&quot;) else: print(&quot;Voc√™ ainda n√£o √© maior de idade.&quot;) Para calcular a complexidade ciclom√°tica deste c√≥digo, precisamos construir o grafo de fluxo de controle. Cada decis√£o, loop ou estrutura de controle de fluxo adiciona uma regi√£o conectada ao grafo, o que aumenta a complexidade ciclom√°tica. No caso deste c√≥digo, temos tr√™s estruturas de controle de fluxo: a declara√ß√£o de if , que tem dois poss√≠veis caminhos (um para a condi√ß√£o True e outro para a condi√ß√£o False ), e duas chamadas de fun√ß√£o print , que n√£o adicionam nenhuma regi√£o conectada ao grafo. Portanto, a complexidade ciclom√°tica deste c√≥digo √© 3. A complexidade ciclom√°tica pode ser √∫til para identificar se√ß√µes de c√≥digo que precisam ser simplificadas ou divididas em fun√ß√µes menores. Neste caso, a fun√ß√£o calcula_idade √© relativamente simples e n√£o √© necess√°rio dividi-la em partes menores. No entanto, se a fun√ß√£o tivesse mais estruturas de controle de fluxo, a complexidade ciclom√°tica seria maior e poderia indicar a necessidade de simplificar o c√≥digo ou dividi-lo em fun√ß√µes menores para facilitar sua compreens√£o e manuten√ß√£o. Outra estrat√©gia para escrever c√≥digo de qualidade √© seguir a regra &quot; 80/24 &quot;. Essa regra sugere que o c√≥digo deve ser escrito em uma caixa de 80 caracteres de largura e 24 linhas de altura. Essa pr√°tica ajuda a manter as fun√ß√µes e m√©todos pequenos e leg√≠veis, facilitando a compreens√£o e manuten√ß√£o do c√≥digo. Al√©m disso, √© importante prestar aten√ß√£o √† documenta√ß√£o do c√≥digo . Uma documenta√ß√£o adequada pode ajudar a garantir que o c√≥digo seja entendido e mantido ao longo do tempo. A documenta√ß√£o pode incluir coment√°rios no c√≥digo, manuais do usu√°rio, e documenta√ß√£o t√©cnica do sistema. Outra forma de evitar o &quot;code rot&quot; √© atrav√©s da revis√£o de c√≥digo. A revis√£o de c√≥digo √© uma t√©cnica em que um ou mais desenvolvedores revisam o c√≥digo de outros desenvolvedores antes de ser incorporado ao projeto. A revis√£o de c√≥digo ajuda a identificar problemas de qualidade no c√≥digo e a garantir que o c√≥digo esteja em conformidade com os padr√µes estabelecidos. Finalmente, √© importante que os desenvolvedores recebam treinamento adequado em boas pr√°ticas de desenvolvimento de software. Isso pode incluir aulas de programa√ß√£o, treinamento em ferramentas de desenvolvimento, e orienta√ß√£o sobre padr√µes de codifica√ß√£o e boas pr√°ticas. Aqui est√£o 10 autores e seus livros que abordam a import√¢ncia de escrever c√≥digo de qualidade e f√°cil de entender: Steve McConnell - Code Complete 2nd Edition Robert C. Martin - Clean Code: A Handbook of Agile Software Craftsmanship Martin Fowler - Refactoring: Improving the Design of Existing Code Joshua Bloch - Effective Java Eric Evans - Domain-Driven Design: Tackling Complexity in the Heart of Software Kent Beck - Test-Driven Development: By Example Michael Feathers - Working Effectively with Legacy Code Andrew Hunt e David Thomas - The Pragmatic Programmer: From Journeyman to Master Dan North - Accelerated Agile: Techniques for Directing Agile Development Jeff Atwood e Joel Spolsky - The Best Software Writing I: Selected and Introduced by Joel Spolsky O &quot;code rot&quot; √© um problema comum em projetos de longo prazo e pode ser evitado atrav√©s da ado√ß√£o de padr√µes de qualidade para o c√≥digo. Isso pode incluir limites na complexidade ciclom√°tica, a regra &quot;80/24&quot;, a documenta√ß√£o adequada, a revis√£o de c√≥digo, e o treinamento em boas pr√°ticas de desenvolvimento de software. Ao adotar essas pr√°ticas, os desenvolvedores podem garantir que o c√≥digo seja f√°cil de entender, manter e evoluir ao longo do tempo. Bora lubrificar esse c√≥digo!" />
<link rel="canonical" href="https://www.gpupo.com/artigos/code-rot,-complexidade-ciclomatica-e-a-qualidade-de-codigo/" />
<meta property="og:url" content="https://www.gpupo.com/artigos/code-rot,-complexidade-ciclomatica-e-a-qualidade-de-codigo/" />
<meta property="og:site_name" content="Gilmar Pupo" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-14T13:12:00-03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Code Rot, Complexidade Ciclom√°tica e a Qualidade de c√≥digo" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-14T13:12:00-03:00","datePublished":"2023-03-14T13:12:00-03:00","description":"Vamos falar da ferrugem do software ? O termo &quot; code rot &quot; descreve a deteriora√ß√£o gradual da qualidade do c√≥digo em um software ao longo do tempo. Esse problema √© comum em projetos de longo prazo, onde muitas pessoas trabalham em diferentes partes do c√≥digo sem se preocupar com a qualidade geral do projeto. A principal causa do &quot;code rot&quot; √© a falta de aten√ß√£o aos detalhes e √† qualidade do c√≥digo. Muitas vezes, as mudan√ßas no c√≥digo s√£o feitas sem considerar o impacto no restante do projeto, o que pode levar a problemas de compatibilidade e complexidade desnecess√°ria. Com o tempo, essas pequenas mudan√ßas se acumulam e resultam em um c√≥digo dif√≠cil de entender, manter e evoluir. Para evitar o &quot;code rot&quot;, √© importante estabelecer padr√µes de qualidade para o c√≥digo. Uma das formas mais eficazes de fazer isso √© por meio de limites e acordos. Por exemplo, a complexidade ciclom√°tica pode ser usada para definir um limite para a complexidade do c√≥digo. A complexidade ciclom√°tica √© uma medida da complexidade estrutural do c√≥digo, e √© definida como o n√∫mero de caminhos independentes em um programa. Limitar a complexidade ciclom√°tica a um n√≠vel aceit√°vel pode ajudar a manter o c√≥digo leg√≠vel e f√°cil de entender. Complexidade ciclom√°tica √© uma medida num√©rica que indica a complexidade de um programa de software. A complexidade ciclom√°tica mede o n√∫mero de caminhos distintos que um programa pode seguir durante sua execu√ß√£o. Isso inclui caminhos de decis√£o em condicionais, loops e estruturas de controle de fluxo. A complexidade ciclom√°tica √© calculada a partir do grafo de fluxo de controle do programa. O grafo de fluxo de controle √© um diagrama que representa graficamente as diferentes decis√µes, loops e estruturas de controle de fluxo de um programa. A partir desse diagrama, a complexidade ciclom√°tica pode ser calculada contando o n√∫mero de regi√µes conectadas, que correspondem ao n√∫mero de caminhos independentes que podem ser percorridos atrav√©s do c√≥digo. Uma alta complexidade ciclom√°tica pode indicar que um programa √© dif√≠cil de entender, manter e testar. Isso ocorre porque o programa tem muitos caminhos poss√≠veis de execu√ß√£o, aumentando a chance de erros e tornando o c√≥digo dif√≠cil de compreender. A complexidade ciclom√°tica tamb√©m pode indicar √°reas do c√≥digo que precisam ser reestruturadas para melhorar sua qualidade e legibilidade. A complexidade ciclom√°tica pode ser usada para estabelecer limites no c√≥digo e ajudar os desenvolvedores a escrever programas mais claros e leg√≠veis. Por exemplo, algumas equipes de desenvolvimento estabelecem um limite m√°ximo de complexidade ciclom√°tica para cada fun√ß√£o ou m√©todo. Quando um m√©todo excede esse limite, ele √© considerado complexo demais e precisa ser reescrito ou dividido em fun√ß√µes menores. Vamos considerar o seguinte c√≥digo de exemplo em Python: def calcula_idade(nome, ano_nascimento): ano_atual = 2023 idade = ano_atual - ano_nascimento print(nome, &quot;tem&quot;, idade, &quot;anos.&quot;) if idade &gt;= 18: print(&quot;Voc√™ j√° √© maior de idade.&quot;) else: print(&quot;Voc√™ ainda n√£o √© maior de idade.&quot;) Para calcular a complexidade ciclom√°tica deste c√≥digo, precisamos construir o grafo de fluxo de controle. Cada decis√£o, loop ou estrutura de controle de fluxo adiciona uma regi√£o conectada ao grafo, o que aumenta a complexidade ciclom√°tica. No caso deste c√≥digo, temos tr√™s estruturas de controle de fluxo: a declara√ß√£o de if , que tem dois poss√≠veis caminhos (um para a condi√ß√£o True e outro para a condi√ß√£o False ), e duas chamadas de fun√ß√£o print , que n√£o adicionam nenhuma regi√£o conectada ao grafo. Portanto, a complexidade ciclom√°tica deste c√≥digo √© 3. A complexidade ciclom√°tica pode ser √∫til para identificar se√ß√µes de c√≥digo que precisam ser simplificadas ou divididas em fun√ß√µes menores. Neste caso, a fun√ß√£o calcula_idade √© relativamente simples e n√£o √© necess√°rio dividi-la em partes menores. No entanto, se a fun√ß√£o tivesse mais estruturas de controle de fluxo, a complexidade ciclom√°tica seria maior e poderia indicar a necessidade de simplificar o c√≥digo ou dividi-lo em fun√ß√µes menores para facilitar sua compreens√£o e manuten√ß√£o. Outra estrat√©gia para escrever c√≥digo de qualidade √© seguir a regra &quot; 80/24 &quot;. Essa regra sugere que o c√≥digo deve ser escrito em uma caixa de 80 caracteres de largura e 24 linhas de altura. Essa pr√°tica ajuda a manter as fun√ß√µes e m√©todos pequenos e leg√≠veis, facilitando a compreens√£o e manuten√ß√£o do c√≥digo. Al√©m disso, √© importante prestar aten√ß√£o √† documenta√ß√£o do c√≥digo . Uma documenta√ß√£o adequada pode ajudar a garantir que o c√≥digo seja entendido e mantido ao longo do tempo. A documenta√ß√£o pode incluir coment√°rios no c√≥digo, manuais do usu√°rio, e documenta√ß√£o t√©cnica do sistema. Outra forma de evitar o &quot;code rot&quot; √© atrav√©s da revis√£o de c√≥digo. A revis√£o de c√≥digo √© uma t√©cnica em que um ou mais desenvolvedores revisam o c√≥digo de outros desenvolvedores antes de ser incorporado ao projeto. A revis√£o de c√≥digo ajuda a identificar problemas de qualidade no c√≥digo e a garantir que o c√≥digo esteja em conformidade com os padr√µes estabelecidos. Finalmente, √© importante que os desenvolvedores recebam treinamento adequado em boas pr√°ticas de desenvolvimento de software. Isso pode incluir aulas de programa√ß√£o, treinamento em ferramentas de desenvolvimento, e orienta√ß√£o sobre padr√µes de codifica√ß√£o e boas pr√°ticas. Aqui est√£o 10 autores e seus livros que abordam a import√¢ncia de escrever c√≥digo de qualidade e f√°cil de entender: Steve McConnell - Code Complete 2nd Edition Robert C. Martin - Clean Code: A Handbook of Agile Software Craftsmanship Martin Fowler - Refactoring: Improving the Design of Existing Code Joshua Bloch - Effective Java Eric Evans - Domain-Driven Design: Tackling Complexity in the Heart of Software Kent Beck - Test-Driven Development: By Example Michael Feathers - Working Effectively with Legacy Code Andrew Hunt e David Thomas - The Pragmatic Programmer: From Journeyman to Master Dan North - Accelerated Agile: Techniques for Directing Agile Development Jeff Atwood e Joel Spolsky - The Best Software Writing I: Selected and Introduced by Joel Spolsky O &quot;code rot&quot; √© um problema comum em projetos de longo prazo e pode ser evitado atrav√©s da ado√ß√£o de padr√µes de qualidade para o c√≥digo. Isso pode incluir limites na complexidade ciclom√°tica, a regra &quot;80/24&quot;, a documenta√ß√£o adequada, a revis√£o de c√≥digo, e o treinamento em boas pr√°ticas de desenvolvimento de software. Ao adotar essas pr√°ticas, os desenvolvedores podem garantir que o c√≥digo seja f√°cil de entender, manter e evoluir ao longo do tempo. Bora lubrificar esse c√≥digo!","headline":"Code Rot, Complexidade Ciclom√°tica e a Qualidade de c√≥digo","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gpupo.com/artigos/code-rot,-complexidade-ciclomatica-e-a-qualidade-de-codigo/"},"url":"https://www.gpupo.com/artigos/code-rot,-complexidade-ciclomatica-e-a-qualidade-de-codigo/"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.gpupo.com/feed.xml" title="Gilmar Pupo" /><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7VM0ZXN60"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Q7VM0ZXN60');
</script>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"></head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Gilmar Pupo</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/readme/">üõ†Ô∏èComo fiz esse site</a>
  <a class="nav-item" href="/about/">üìú About</a>
  <a class="nav-item" href="/lessons/">üßæ Aulas</a>
  <a class="nav-item" href="/livros/">üìöLivros</a>
  <a class="nav-item" href="/">üìù Artigos</a>
  <a class="nav-item" href="/mentoria/">üìú Mentoria</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Code Rot, Complexidade Ciclom√°tica e a Qualidade de c√≥digo</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2023-03-14T13:12:00-03:00" itemprop="datePublished">
        Mar 14, 2023
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div>
<p>
Vamos falar da ferrugem do software ? O termo "
<strong>
code rot
</strong>
" descreve a deteriora√ß√£o gradual da qualidade do c√≥digo em um software ao longo do tempo. Esse problema √© comum em projetos de longo prazo, onde muitas pessoas trabalham em diferentes partes do c√≥digo sem se preocupar com a qualidade geral do projeto.
</p>
<p>
A principal causa do "code rot" √© a falta de aten√ß√£o aos detalhes e √† qualidade do c√≥digo. Muitas vezes, as mudan√ßas no c√≥digo s√£o feitas sem considerar o impacto no restante do projeto, o que pode levar a problemas de compatibilidade e complexidade desnecess√°ria. Com o tempo, essas pequenas mudan√ßas se acumulam e resultam em um c√≥digo dif√≠cil de entender, manter e evoluir.
</p>
<p>
Para evitar o "code rot", √© importante estabelecer padr√µes de qualidade para o c√≥digo. Uma das formas mais eficazes de fazer isso √© por meio de limites e acordos. Por exemplo, a
<strong>
complexidade ciclom√°tica
</strong>
pode ser usada para definir um limite para a complexidade do c√≥digo. A complexidade ciclom√°tica √© uma medida da complexidade estrutural do c√≥digo, e √© definida como o n√∫mero de caminhos independentes em um programa. Limitar a complexidade ciclom√°tica a um n√≠vel aceit√°vel pode ajudar a manter o c√≥digo leg√≠vel e f√°cil de entender.
</p>
<p>
<br />
</p>
<div>
<hr />
</div>
<p>
<strong>
Complexidade ciclom√°tica
</strong>
√© uma medida num√©rica que indica a complexidade de um programa de software. A complexidade ciclom√°tica mede o n√∫mero de caminhos distintos que um programa pode seguir durante sua execu√ß√£o. Isso inclui caminhos de decis√£o em condicionais, loops e estruturas de controle de fluxo.
</p>
<p>
A complexidade ciclom√°tica √© calculada a partir do grafo de fluxo de controle do programa. O grafo de fluxo de controle √© um diagrama que representa graficamente as diferentes decis√µes, loops e estruturas de controle de fluxo de um programa. A partir desse diagrama, a complexidade ciclom√°tica pode ser calculada contando o n√∫mero de regi√µes conectadas, que correspondem ao n√∫mero de caminhos independentes que podem ser percorridos atrav√©s do c√≥digo.
</p>
<p>
<strong>
Uma alta complexidade ciclom√°tica pode indicar que um programa √© dif√≠cil de entender, manter e testar.
</strong>
Isso ocorre porque o programa tem muitos caminhos poss√≠veis de execu√ß√£o, aumentando a chance de erros e tornando o c√≥digo dif√≠cil de compreender. A complexidade ciclom√°tica tamb√©m pode indicar √°reas do c√≥digo que precisam ser reestruturadas para melhorar sua qualidade e legibilidade.
</p>
<p>
A complexidade ciclom√°tica pode ser usada para estabelecer
<strong>
limites
</strong>
no c√≥digo e ajudar os desenvolvedores a escrever programas mais claros e leg√≠veis. Por exemplo, algumas equipes de desenvolvimento estabelecem um limite m√°ximo de complexidade ciclom√°tica para cada fun√ß√£o ou m√©todo. Quando um m√©todo excede esse limite, ele √© considerado complexo demais e precisa ser reescrito ou dividido em fun√ß√µes menores.
</p>
<p>
Vamos considerar o seguinte c√≥digo de exemplo em Python:
</p>
<pre spellcheck="false">def calcula_idade(nome, ano_nascimento):
ano_atual = 2023
idade = ano_atual - ano_nascimento
print(nome, "tem", idade, "anos.")
if idade &gt;= 18:
print("Voc√™ j√° √© maior de idade.")
else:
print("Voc√™ ainda n√£o √© maior de idade.")
</pre>
<p>
Para calcular a complexidade ciclom√°tica deste c√≥digo, precisamos construir o grafo de fluxo de controle. Cada decis√£o, loop ou estrutura de controle de fluxo adiciona uma regi√£o conectada ao grafo, o que aumenta a complexidade ciclom√°tica.
</p>
<p>
No caso deste c√≥digo, temos tr√™s estruturas de controle de fluxo: a declara√ß√£o de
<strong>
if
</strong>
, que tem dois poss√≠veis caminhos (um para a condi√ß√£o
<strong>
True
</strong>
e outro para a condi√ß√£o
<strong>
False
</strong>
), e duas chamadas de fun√ß√£o
<strong>
print
</strong>
, que n√£o adicionam nenhuma regi√£o conectada ao grafo. Portanto, a complexidade ciclom√°tica deste c√≥digo √© 3.
</p>
<p>
A complexidade ciclom√°tica pode ser √∫til para identificar se√ß√µes de c√≥digo que precisam ser simplificadas ou divididas em fun√ß√µes menores. Neste caso, a fun√ß√£o
<strong>
calcula_idade
</strong>
√© relativamente simples e n√£o √© necess√°rio dividi-la em partes menores. No entanto, se a fun√ß√£o tivesse mais estruturas de controle de fluxo, a complexidade ciclom√°tica seria maior e poderia indicar a necessidade de simplificar o c√≥digo ou dividi-lo em fun√ß√µes menores para facilitar sua compreens√£o e manuten√ß√£o.
</p>
<div>
<hr />
</div>
<p>
Outra estrat√©gia para escrever c√≥digo de qualidade √© seguir a regra "
<strong>
80/24
</strong>
". Essa regra sugere que o c√≥digo deve ser escrito em uma caixa de 80 caracteres de largura e 24 linhas de altura. Essa pr√°tica ajuda a manter as fun√ß√µes e m√©todos pequenos e leg√≠veis, facilitando a compreens√£o e manuten√ß√£o do c√≥digo.
</p>
<p>
Al√©m disso, √© importante prestar aten√ß√£o √†
<strong>
documenta√ß√£o do c√≥digo
</strong>
. Uma documenta√ß√£o adequada pode ajudar a garantir que o c√≥digo seja entendido e mantido ao longo do tempo. A documenta√ß√£o pode incluir coment√°rios no c√≥digo, manuais do usu√°rio, e documenta√ß√£o t√©cnica do sistema.
</p>
<p>
Outra forma de evitar o "code rot" √© atrav√©s da revis√£o de c√≥digo. A
<strong>
revis√£o de c√≥digo
</strong>
√© uma t√©cnica em que um ou mais desenvolvedores revisam o c√≥digo de outros desenvolvedores antes de ser incorporado ao projeto. A revis√£o de c√≥digo ajuda a identificar problemas de qualidade no c√≥digo e a garantir que o c√≥digo esteja em conformidade com os padr√µes estabelecidos.
</p>
<p>
Finalmente, √© importante que os desenvolvedores recebam treinamento adequado em boas pr√°ticas de desenvolvimento de software. Isso pode incluir aulas de programa√ß√£o, treinamento em ferramentas de desenvolvimento, e orienta√ß√£o sobre padr√µes de codifica√ß√£o e boas pr√°ticas.
</p>
<p>
Aqui est√£o 10 autores e seus livros que abordam a import√¢ncia de escrever c√≥digo de qualidade e f√°cil de entender:
</p>
<ol>
<li>
Steve McConnell - Code Complete 2nd Edition
</li>
<li>
Robert C. Martin - Clean Code: A Handbook of Agile Software Craftsmanship
</li>
<li>
Martin Fowler - Refactoring: Improving the Design of Existing Code
</li>
<li>
Joshua Bloch - Effective Java
</li>
<li>
Eric Evans - Domain-Driven Design: Tackling Complexity in the Heart of Software
</li>
<li>
Kent Beck - Test-Driven Development: By Example
</li>
<li>
Michael Feathers - Working Effectively with Legacy Code
</li>
<li>
Andrew Hunt e David Thomas - The Pragmatic Programmer: From Journeyman to Master
</li>
<li>
Dan North - Accelerated Agile: Techniques for Directing Agile Development
</li>
<li>
Jeff Atwood e Joel Spolsky - The Best Software Writing I: Selected and Introduced by Joel Spolsky
</li>
</ol>
<p>
O "code rot" √© um problema comum em projetos de longo prazo e pode ser evitado atrav√©s da ado√ß√£o de padr√µes de qualidade para o c√≥digo. Isso pode incluir limites na complexidade ciclom√°tica, a regra "80/24", a documenta√ß√£o adequada, a revis√£o de c√≥digo, e o treinamento em boas pr√°ticas de desenvolvimento de software. Ao adotar essas pr√°ticas, os desenvolvedores podem garantir que o c√≥digo seja f√°cil de entender, manter e evoluir ao longo do tempo.
</p>
<p>
Bora lubrificar esse c√≥digo!
</p>
</div>

  </div>

  <a class="u-url" href="/artigos/code-rot,-complexidade-ciclomatica-e-a-qualidade-de-codigo/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
          <a href="https://www.gpupo.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>RSS</span>
          </a><a class="page-link" href="/">üìù Artigos</a><a class="page-link" href="/readme/">üõ†Ô∏èComo fiz esse site</a></div>
    </div>


  </div>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <a class="libutton"
          href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">Subscribe on LinkedIn</a>
        <div class="newsletter-text">
        üì∞ <a href="https://www.linkedin.com/build-relation/newsletter-follow?entityUrn=7039318039770640384"
          target="_blank">NEWSLETTER</a>
          <b>Bora Gil RePensar</b>:
          <i>Repense comigo temas relacionados √† inova√ß√£o, e-commerce e tecnologia</i>
        </div>
      </div>
    </div>
  </div>
</footer>
</body>

</html>
